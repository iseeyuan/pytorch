syntax = "proto2";

import "caffe2/proto/torch.proto";

package instruction;

message OperationProto {
  required string name = 1;
  required string overload_name = 2;
}

message VariableProto {
  required uint32 unique_id = 1;
  optional bool free_flag = 2; // can generate when loading?
}

message AttributeValueProto {
  enum AttributKind {
    f = 0;  // double
    fs = 1; 
    i = 2; 
    is = 3; 
    s = 4; 
    ss = 5;
    t = 6; 
    ts = 7; 
    b = 8; // bool
    bs = 9;
    gs = 10; // GenericList
    gd = 11; // GenericDict
    tp = 12; // Tuple
    blb = 13; // blob
    ftr = 14; // future
    dvc = 15; // device
    obj = 16; // object
    n = 17; //None
  }
  required AttributKind kind = 1;
  optional double float_value = 2;
  optional int64 int_value = 3;
  optional string string_value = 4;
  // if it's a tensor, the offset into the tensor table
  optional int64 tensor_id = 5;

  repeated int64 int_list = 6;
  repeated double float_list = 7;
  optional bool bool_value = 8;
  repeated bool bool_list = 9; 
}

message InstructionProto { //instruction
  required OperationProto op = 1; 
  repeated VariableProto inputs = 2;
  repeated VariableProto outputs =3;
// Use AttributeValue to hold the constants needed in this instruction,
// if there is any. Currently I only saw them in Constant operators.
  repeated AttributeValueProto attributes = 4;
}

message InstructionListProto { //instruction list
  required string name = 1;
  repeated InstructionProto instructions = 2;
  repeated torch.TensorDef tensors = 3;
}